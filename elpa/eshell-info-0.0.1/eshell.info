This is eshell.info, produced by makeinfo version 4.13 from eshell.texi.

This is the first edition of the `Eshell Manual'.

INFO-DIR-SECTION Packages
START-INFO-DIR-ENTRY
* Eshell: (eshell.info).	An Emacs command shell.
END-INFO-DIR-ENTRY

   This document describes how to use and program the Emacs Command
Shell, or "Eshell".  No guarantee is made as the usability of this
software.  Use it at your own risk.  Neither is this documentation
guaranteed to be accurate or sufficient.

   Copyright (C) 1999, 2000 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.


File: eshell.info,  Node: Top,  Next: The Emacs shell,  Prev: (dir),  Up: (dir)

The Emacs Shell: Eshell
***********************

   Eshell is a command shell implemented entirely in Emacs Lisp.  It
invokes no external processes beyond those requested by the user.  It
is intended to be a functional replacement for command shells such as
bash, zsh, rc, 4dos; since Emacs itself is capable of handling most of
the tasks accomplished by such tools.

* Menu:

* The Emacs shell::                 eshell.

Core Functionality
* Argument parsing::                eshell-arg.
* Command invocation::              eshell-cmd.
* External commands::               eshell-ext.
* I/O management::                  eshell-io.
* User interface::                  eshell-mode.
* Extension modules::               eshell-module.
* Command options processing::      eshell-opt.
* Process management::              eshell-proc.
* Eshell test suite::               eshell-test.
* General utilities::               eshell-util.
* Variable handling::               eshell-var.

Optional Functionality
* Command aliases::                 eshell-alias.
* Login banner::                    eshell-banner.
* Basic shell commands::            eshell-basic.
* Argument completion::             eshell-cmpl.
* Directory navigation::            eshell-dirs.
* Extended filename globbing::      eshell-glob.
* History list management::         eshell-hist.
* Implementation of `ls' in Lisp::  eshell-ls.
* Value modifiers and predicates::  eshell-pred.
* Command prompts::                 eshell-prompt.
* Rebind keys at input::            eshell-rebind.
* Running script files.::           eshell-script.
* Smart display of output::         eshell-smart.
* Running visual commands::         eshell-term.
* UNIX commands in Lisp::           eshell-unix.
* Extra alias functions::           eshell-xtra.


File: eshell.info,  Node: The Emacs shell,  Next: Argument parsing,  Prev: Top,  Up: Top

1 The Emacs shell
*****************

* Menu:

* What does Eshell offer you?::
* Supported versions of Emacs::
* Known problems::
* Downloading the latest version::
* Eshell is free software::
* How to begin::
* Philosophy::
* Influences::
* User Options::
* Running Eshell::
* Reporting bugs::


File: eshell.info,  Node: What does Eshell offer you?,  Next: Supported versions of Emacs,  Prev: The Emacs shell,  Up: The Emacs shell

1.1 What does Eshell offer you?
===============================

Despite the sheer fact that running an Emacs shell can be fun, here are
a few of the unique features offered by Eshell:

   * Integration with the Emacs Lisp programming environment

   * A high degree of configurability

   * The ability to have the same shell on every system Emacs has been
     ported to. Since Eshell imposes no external requirements, and
     relies upon only the Lisp functions exposed by Emacs, it is quite
     operating system independent. Several of the common UNIX commands,
     such as ls, mv, rm, ln, etc., have been implemented in Lisp in
     order to provide a more consistent work environment.

   For those who might be using an older version of Eshell, version 2.1
represents an entirely new, module-based architecture. It supports most
of the features offered by modern shells. Here is a brief list of some
of its more visible features:

   * Command argument completion (tcsh, zsh)

   * Input history management (bash)

   * Intelligent output scrolling

   * Psuedo-devices (such as "/dev/clip" for copying to the clipboard)

   * Extended globbing (zsh)

   * Argument and globbing predication (zsh)

   * I/O redirection to buffers, files, symbols, processes, etc.

   * Many niceties otherwise seen only in 4DOS

   * Alias functions, both Lisp and Eshell-syntax

   * Piping, sequenced commands, background jobs, etc...



File: eshell.info,  Node: Supported versions of Emacs,  Next: Known problems,  Prev: What does Eshell offer you?,  Up: The Emacs shell

1.2 Supported versions of Emacs
===============================

Eshell was designed to run on Emacs 20.4 or higher, and XEmacs 21.1 or
higher.  It was tested on GNU/Linux, Windows NT 4.0, and Windows 2000.


File: eshell.info,  Node: Known problems,  Next: Downloading the latest version,  Prev: Supported versions of Emacs,  Up: The Emacs shell

1.3 Known problems
==================

If you try to run Eshell on other versions of Emacs, here are some
common problems you may run into, and how to overcome them:

   * Emacs 20.3: Pcomplete fails to byte compile.  Instead of typing
     "make install" in the Pcomplete directory, type: "make
     pcmpl-auto.el install_el".  Then, copy the file "pcmpl-auto.el"
     into the directory that pcomplete was just installed into.  Why
     this is failing is a mystery to me.  It appears that
     byte-compiling pcomplete from a running Emacs session works just
     fine.



File: eshell.info,  Node: Downloading the latest version,  Next: Eshell is free software,  Prev: Known problems,  Up: The Emacs shell

1.4 Downloading the latest version
==================================

Eshell can be downloaded via HTTP as a tar file
(http://www.emacs.org/~johnw/Emacs/packages/eshell.tar.gz), or as a
Windows .ZIP file
(http://www.emacs.org/~johnw/Emacs/packages/eshell.zip).


File: eshell.info,  Node: Eshell is free software,  Next: How to begin,  Prev: Downloading the latest version,  Up: The Emacs shell

1.5 Eshell is free software
===========================

Eshell is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

   This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

   You should have received a copy of the GNU General Public License
along with Eshell; see the file COPYING.  If not, write to the Free
Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.


File: eshell.info,  Node: How to begin,  Next: Philosophy,  Prev: Eshell is free software,  Up: The Emacs shell

1.6 How to begin
================

To start using Eshell, add the following to your .emacs file:

     (load "eshell-auto")

   This will define all of the necessary autoloads.

   Now type `M-x eshell'.  See the INSTALL file for full installation
instructions.


File: eshell.info,  Node: Philosophy,  Next: Influences,  Prev: How to begin,  Up: The Emacs shell

1.7 Philosophy
==============

A shell is a layer which metaphorically surrounds the kernel, or heart
of an operating system.  This kernel can be seen as an engine of pure
functionality, waiting to serve, while the user programs take advantage
of that functionality to accomplish their purpose.

   The shell's role is to make that functionality accessible to the
user in an unformed state.  Very roughly, it associates kernel
functionality with textual commands, allowing the user to interact with
the operating system via linguistic constructs.  Process invocation is
perhaps the most significant form this takes, using the kernel's `fork'
and `exec' functions.

   Other programs also interact with the functionality of the kernel,
but these user applications typically offer a specific range of
functionality, and thus are not classed as "shells" proper.  (What they
lose in quiddity, they gain in rigidity).

   Emacs is also a user application, but it does make the functionality
of the kernel accessible through an interpreted language--namely, Lisp.
For that reason, there is little preventing Emacs from serving the same
role as a modern shell.  It too can manipulate the kernel in an
unpredetermined way to cause system changes.  All it's missing is the
shell-ish linguistic model.

   Enter Eshell.  Eshell translates "shell-like" syntax into Lisp in
order to exercise the kernel in the same manner as typical system
shells.  There is a fundamental difference here, however, although it
may seem subtle at first...

   Shells like csh and Bourne shell were written several decades ago,
in different times, under more restrictive circumstances.  This
confined perspective shows itself in the paradigm used by nearly all
command-line shells since.  They are linear in conception, byte
stream-based, sequential, and confined to movement within a single host
machine.

   Emacs, on the other hand, is more than just a limited translator
that can invoke subprocesses and redirect file handles.  It also
manages character buffers, windowing frames, network connections,
registers, bookmarks, processes, etc.  In other words, it's a very
multi-dimensional environment, within which eshell emulates a highly
linear methodology.

   Taking a moment, let's look at how this could affect the future of a
shell allowed to develop in such a wider field of play:

   * There is no reason why directory movement should be linear, and
     confined to a single file-system.  Emacs, through w3 and ange-ftp,
     has access to the entire Web.  Why not allow a user to cd to
     multiple directories simultaneously, for example?  It might make
     some tasks easier, such as diff'ing files separated by very long
     pathnames.

   * Data sources are available from anywhere Emacs can derive
     information from: not just from files or the output of other
     processes.

   * Multiple shell invocations all share the same environment--even
     the same process list!  It would be possible to have "process
     views", so that one buffer is watching standard output, another
     standard error, and another the result of standard output grep'd
     through a regular expression...

   * It is not necessary to "leave" the shell, losing all input and
     output history, environment variables, directory stack, etc.
     Emacs could save the contents of your eshell environment, and
     restore all of it (or at least as much as possible) each time you
     restart.  This could occur automatically, without requiring
     complex initialization scripts.

   * Typos occur all of the time; many of them are repeats of common
     errors, such as `dri' for `dir'.  Since executing non-existent
     programs is rarely the intention of the user, eshell could prompt
     for the replacement string, and then record that in a database of
     known misspellings. (Note: The typo at the beginning of this
     paragraph wasn't discovered until two months after I wrote the
     text; it was not intentional).

   * Emacs' register and bookmarking facilities can be used for
     remembering where you've been, and what you've seen--to varying
     levels of persistence.  They could perhaps even be tied to
     specific "moments" during eshell execution, which would include
     the environment at that time, as well as other variables.
     Although this would require functionality orthogonal to Emacs' own
     bookmarking facilities, the interface used could be made to
     operate very similarly.

   This presents a brief idea of what the fuller dimensionality of an
Emacs shell could offer.  It's not just the language of a shell that
determines how it's used, but also the Weltanschauung underlying its
design--and which is felt behind even the smallest feature.  I would
hope the freedom provided by using Emacs as a parent environment will
invite rich ideas from others.  It certainly feels as though all I've
done so far is to tie down the horse, so to speak, so that he will run
at a man's pace.


File: eshell.info,  Node: Influences,  Next: User Options,  Prev: Philosophy,  Up: The Emacs shell

1.8 Influences
==============

The author of Eshell has been a long-time user of the following shells,
all of which contributed to Eshell's design:

   * rc

   * bash

   * zsh

   * sh

   * 4nt

   * csh


File: eshell.info,  Node: User Options,  Next: Running Eshell,  Prev: Influences,  Up: The Emacs shell

1.9 User Options
================

The following user options modify the behavior of Eshell overall.

 -- User Option: eshell-unload-hook
     A hook run when Eshell is unloaded from memory.

 -- User Option: eshell-buffer-name
     The basename used for Eshell buffers.

 -- User Option: eshell-directory-name
     The directory where Eshell control files should be kept.

 -- User Option: eshell-prefer-to-shell
     If non-nil, \[shell-command] will use Eshell instead of shell-mode.


File: eshell.info,  Node: Running Eshell,  Next: Reporting bugs,  Prev: User Options,  Up: The Emacs shell

1.10 Running Eshell
===================

There are only three commands used to invoke Eshell.  The first two are
intended for interactive use, while the third is meant for programmers.
They are:

 -- Command: eshell &optional ARG
     Create an interactive Eshell buffer.  The buffer used for Eshell
     sessions is determined by the value of `eshell-buffer-name'.  If
     there is already an Eshell session active in that buffer, Emacs
     will simply switch to it.  Otherwise, a new session will begin.  A
     new session is always created if the the prefix argument ARG is
     specified.  Returns the buffer selected (or created).

 -- Command: eshell-command COMMAND &optional ARG
     Execute the Eshell command string COMMAND.  With prefix ARG,
     insert output into the current buffer at point.

 -- Command: eshell-command-result COMMAND &optional STATUS-VAR
     Execute the given Eshell COMMAND, and return the result.  The
     result might be any Lisp object.  If STATUS-VAR is a symbol, it
     will be set to the exit status of the command.  This is the only
     way to determine whether the value returned corresponding to a
     successful execution.


File: eshell.info,  Node: Reporting bugs,  Prev: Running Eshell,  Up: The Emacs shell

1.11 Reporting bugs
===================

Since Eshell has not yet been in use by a wide audience, and since the
number of possible configurations is quite large, it is certain that
many bugs slipped past the rigors of testing it was put through.  If
you do encounter a bug, on any system, please report it--in addition to
any particular oddities in your configuration --so that the problem may
be corrected for the benefit of others.

 -- Command: eshell-report-bug TOPIC
     Report a bug in Eshell.  Prompts for the TOPIC.  Leaves you in a
     mail buffer.  Please include any configuration details that might
     be involved.


File: eshell.info,  Node: Argument parsing,  Next: Command invocation,  Prev: The Emacs shell,  Up: Top

2 Argument parsing
******************

Argument parsing involves transforming the arguments passed on the
command line into equivalent Lisp forms that, when evaluated, will
yield the values intended.

   Parsing of arguments can be extended by adding functions to the hook
`eshell-parse-argument-hook'.  For a good example of this, see
`eshell-parse-drive-letter', defined in eshell-dirs.el.

 -- User Option: eshell-parse-argument-hook
     Define how to process Eshell command line arguments.  When each
     function on this hook is called, point will be at the current
     position within the argument list.  The function should either
     return nil, meaning that it did no argument parsing, or it should
     return the result of the parse as a sexp.  It is also responsible
     for moving the point forward to reflect the amount of input text
     that was parsed.

     If no function handles the current character at point, it will be
     treated as a literal character.


File: eshell.info,  Node: Command invocation,  Next: External commands,  Prev: Argument parsing,  Up: Top

3 Command invocation
********************

Executing an Eshell command is as simple as typing it in and pressing
`RET'.  There are several different kinds of commands, however.

* Menu:

* Invoking external commands::
* Invoking Lisp functions::
* Alias functions::
* Lisp arguments::
* Command hooks::


File: eshell.info,  Node: Invoking external commands,  Next: Invoking Lisp functions,  Prev: Command invocation,  Up: Command invocation

3.1 Invoking external commands
==============================

External commands cause processes to be created, by loading external
executables into memory.  This is what most normal shells do, most of
the time.  For more information, see *note External commands::.


File: eshell.info,  Node: Invoking Lisp functions,  Next: Alias functions,  Prev: Invoking external commands,  Up: Command invocation

3.2 Invoking Lisp functions
===========================

A Lisp function can be invoked using Lisp syntax, or command shell
syntax.  For example, to run `dired' to edit the current directory:

     /tmp $ (dired ".")

   Or:

     /tmp $ dired .

   The latter form is preferable, but the former is more precise, since
it involves no translations.  See *note Argument parsing::, to learn
more about how arguments are transformed before passing them to
commands.

   Ordinarily, if `dired' were also available as an external command,
the external version would be called in preference to any Lisp function
of the same name.  To change this behavior so that Lisp functions
always take precedence, set `eshell-prefer-lisp-functions' to t.

 -- User Option: eshell-prefer-lisp-functions
     If non-nil, prefer Lisp functions to external commands.


File: eshell.info,  Node: Alias functions,  Next: Lisp arguments,  Prev: Invoking Lisp functions,  Up: Command invocation

3.3 Alias functions
===================

Whenever a command is specified using a simple name, such as `ls',
Eshell will first look for a Lisp function of the name `eshell/ls'.  If
it exists, it will be called in preference to any other command which
might have matched the name `ls' (such as command aliases, external
commands, Lisp functions of that name, etc).

   This is the most flexible mechanism for creating new commands, since
it does not pollute the global namespace, yet allows you to use all of
Lisp's facilities to define that piece of functionality.  Most of
Eshell's "builtin" commands are defined as alias functions.


File: eshell.info,  Node: Lisp arguments,  Next: Command hooks,  Prev: Alias functions,  Up: Command invocation

3.4 Lisp arguments
==================

It is possible to invoke a Lisp form as an argument.  This can be done
either by specifying the form as you might in Lisp, or by using the `$'
character to introduce a value-interpolation:

     echo (+ 1 2)

   Or

     echo $(+ 1 2)

   The two forms are equivalent.  The second is required only if the
form being interpolated is within a string, or is a subexpression of a
larger argument:

     echo x$(+ 1 2) "String $(+ 1 2)"

   To pass a Lisp symbol as a argument, use the alternate quoting
syntax, since the single quote character is far too overused in shell
syntax:

     echo #'lisp-symbol

   Backquote can also be used:

     echo `(list ,lisp-symbol)

   Lisp arguments are identified using the following regexp:

 -- User Option: eshell-lisp-regexp
     A regexp which, if matched at beginning of an argument, means Lisp.
     Such arguments will be passed to `read', and then evaluated.


File: eshell.info,  Node: Command hooks,  Prev: Lisp arguments,  Up: Command invocation

3.5 Command hooks
=================

There are several hooks involved with command execution, which can be
used either to change or augment Eshell's behavior.

 -- User Option: eshell-pre-command-hook
     A hook run before each interactive command is invoked.

 -- User Option: eshell-post-command-hook
     A hook run after each interactive command is invoked.

 -- User Option: eshell-prepare-command-hook
     A set of functions called to prepare a named command.  The command
     name and its argument are in `eshell-last-command-name' and
     `eshell-last-arguments'.  The functions on this hook can change
     the value of these symbols if necessary.

     To prevent a command from executing at all, set
     `eshell-last-command-name' to nil.

 -- User Option: eshell-named-command-hook
     A set of functions called before a named command is invoked.  Each
     function will be passed the command name and arguments that were
     passed to `eshell-named-command'.

     If any of the functions returns a non-nil value, the named command
     will not be invoked, and that value will be returned from
     `eshell-named-command'.

     In order to substitute an alternate command form for execution, the
     hook function should throw it using the tag
     `eshell-replace-command'.  For example:

          (add-hook 'eshell-named-command-hook 'subst-with-cd)
          (defun subst-with-cd (command args)
            (throw 'eshell-replace-command
            (eshell-parse-command "cd" args)))

     Although useless, the above code will cause any non-glob, non-Lisp
     command (i.e., `ls' as opposed to `*ls' or `(ls)') to be replaced
     by a call to `cd' using the arguments that were passed to the
     function.

 -- User Option: eshell-pre-rewrite-command-hook
     A hook run before command rewriting begins.  The terms of the
     command to be rewritten is passed as arguments, and may be
     modified in place.  Any return value is ignored.

 -- User Option: eshell-rewrite-command-hook
     A set of functions used to rewrite the command argument.  Once
     parsing of a command line is completed, the next step is to
     rewrite the initial argument into something runnable.

     A module may wish to associate special behavior with certain
     argument syntaxes at the beginning of a command line.  They are
     welcome to do so by adding a function to this hook.  The first
     function to return a substitute command form is the one used.
     Each function is passed the command's full argument list, which is
     a list of sexps (typically forms or strings).

 -- User Option: eshell-post-rewrite-command-hook
     A hook run after command rewriting is finished.  Each function is
     passed the symbol containing the rewritten command, which may be
     modified directly.  Any return value is ignored.


File: eshell.info,  Node: External commands,  Next: I/O management,  Prev: Command invocation,  Up: Top

4 External commands
*******************

External commands are invoked when operating system executables are
loaded into memory, thus beginning a new process.

   To force a command to invoked external, either provide an explicit
pathname for the command argument, or prefix the command name with an
asterix character.  Example:

     grep        ; make invoke `grep' Lisp function, or `eshell/grep'
     /bin/grep   ; will definitely invoke /bin/grep
     * grep        ; will also invoke /bin/grep

 -- User Option: eshell-binary-suffixes
     A list of suffixes used when searching for executable files.

 -- User Option: eshell-force-execution
     If non-nil, try to execute binary files regardless of permissions.
     This can be useful on systems like Windows, where the operating
     system doesn't happen to honor the permission bits in certain
     cases; or in cases where you want to associate an interpreter with
     a particular kind of script file, but the language won't let you
     but a `#!' interpreter line in the file, and you don't want to
     make it executable since nothing else but Eshell will be able to
     understand `eshell-interpreter-alist'.

 -- User Option: eshell-windows-shell-file
     The name of the shell command to use for DOS/Windows batch files.
     This defaults to nil on non-Windows systems, where this variable is
     wholly ignored.

 -- User Option: eshell-interpreter-alist
     An alist defining interpreter substitutions.  Each member is a
     cons cell of the form:

          (MATCH . INTERPRETER)

     MATCH should be a regexp, which is matched against the command
     name, or a function.  If either returns a non-nil value, then
     INTERPRETER will be used for that command.

     If INTERPRETER is a string, it will be called as the command name,
     with the original command name passed as the first argument, with
     all subsequent arguments following.  If INTERPRETER is a function,
     it will be called with all of those arguments.  Note that
     interpreter functions should throw `eshell-replace-command' with
     the alternate command form, or they should return a value
     compatible with the possible return values of
     `eshell-external-command', which see.

 -- User Option: eshell-alternate-command-hook
     A hook run whenever external command lookup fails.  If a functions
     wishes to provide an alternate command, they must throw it using
     the tag `eshell-replace-command'.  This is done because the
     substituted command need not be external at all, and therefore
     must be passed up to a higher level for re-evaluation.

     Or, if the function returns a filename, that filename will be
     invoked with the current command arguments rather than the command
     specified by the user on the command line.

 -- User Option: eshell-command-interpreter-max-length
     The maximum length of any command interpreter string, plus args.


File: eshell.info,  Node: I/O management,  Next: User interface,  Prev: External commands,  Up: Top

5 I/O management
****************

Eshell's I/O management code provides a scheme for treating many
different kinds of objects--symbols, files, buffers, etc.--as though
they were files.

   At the moment, only output redirection is supported in Eshell.  To
use input redirection, the following syntax will work, assuming that
the command after the pipe is always an external command:

     cat <file> | <command>

   Otherwise, output redirection and piping are provided in a manner
consistent with most shells.  Therefore, only unique features are
mentioned here.

* Menu:

* Insertion::
* Pseudo-devices::
* Multiple output targets::


File: eshell.info,  Node: Insertion,  Next: Pseudo-devices,  Prev: I/O management,  Up: I/O management

5.1 Insertion
=============

To insert at the location of point in a buffer, use `>>>':

     echo alpha >>> #<buffer *scratch*>;


File: eshell.info,  Node: Pseudo-devices,  Next: Multiple output targets,  Prev: Insertion,  Up: I/O management

5.2 Pseudo-devices
==================

A few pseudo-devices are provided, since Emacs cannot write directly to
a UNIX device file:

     echo alpha > /dev/null   ; the bit bucket
     echo alpha > /dev/kill   ; set the kill ring
     echo alpha >> /dev/clip  ; append to the clipboard


File: eshell.info,  Node: Multiple output targets,  Prev: Pseudo-devices,  Up: I/O management

5.3 Multiple output targets
===========================

Eshell can write to multiple output targets, including pipes.  Example:

     (+ 1 2) > a > b > c   ; prints number to all three files
     (+ 1 2) > a | wc      ; prints to 'a', and pipes to 'wc'

 -- User Option: eshell-number-of-handles
     The number of file handles that eshell supports.  Currently this
     is standard input, output and error.  But even all of these Emacs
     does not currently support with asynchronous processes (which is
     what eshell uses so that you can continue doing work in other
     buffers) .

 -- User Option: eshell-output-handle
     The index of the standard output handle.

 -- User Option: eshell-error-handle
     The index of the standard error handle.

 -- User Option: eshell-buffer-shorthand
     If non-nil, a symbol name can be used for a buffer in redirection.
     If nil, redirecting to a buffer requires buffer name syntax.  If
     this variable is set, redirection directly to Lisp symbols will be
     impossible.

     Example:

          echo hello > '*scratch*  ; works if `eshell-buffer-shorthand' is t
          echo hello > #<buffer *scratch*>  ; always works

 -- User Option: eshell-print-queue-size
     The size of the print queue, for doing buffered printing.  This is
     basically a speed enhancement, to avoid blocking the Lisp code
     from executing while Emacs is redisplaying.


File: eshell.info,  Node: User interface,  Next: Extension modules,  Prev: I/O management,  Up: Top

6 User interface
****************

This module contains code for handling input from the user.

   Basically, Eshell is used just like shell mode (<M-x shell>).  The
keystrokes for navigating the buffer, and accessing the command
history, are identical.  Unlike shell mode, however, Eshell mode's
governing process is Emacs itself.  With shell mode, an inferior shell
process is executed that communicates with Emacs via comint --a mode
for handling sub-process interaction.  Eshell mode, on the other hand,
is a truly native Emacs shell.  No subprocess are invoked except the
ones requested by the user at the prompt.

   After entering a command, use `RET' to invoke it ([Command
invocation]) .  If there is a command on disk, it will be executed as
in a normal shell.  If there is no command by that name on disk, but a
Lisp function with that name is defined, the Lisp function will be
called, using the arguments passed on the command line.

   Some of the other features of the command interaction mode are:

   * `M-RET' can be used to accumulate further commands while a command
     is currently running.  Since all input is passed to the subprocess
     being executed, there is no automatic input queueing as there is
     with other shells.

   * `C-c C-t' can be used to truncate the buffer if it grows too large.

   * `C-c C-r' will move point to the beginning of the output of the
     last command.  With a prefix argument, it will narrow to view only
     that output.

   * `C-c C-o' will delete the output from the last command.

   * `C-c C-f' will move forward a complete shell argument.

   * `C-c C-b' will move backward a complete shell argument.

 -- User Option: eshell-mode-unload-hook
     A hook that gets run when `eshell-mode' is unloaded.

 -- User Option: eshell-mode-hook
     A hook that gets run when `eshell-mode' is entered.

 -- User Option: eshell-first-time-mode-hook
     A hook that gets run the first time `eshell-mode' is entered.
     That is to say, the first time during an Emacs session.

 -- User Option: eshell-exit-hook
     A hook that is run whenever `eshell' is exited.  This hook is only
     run if exiting actually kills the buffer.

 -- User Option: eshell-kill-on-exit
     If non-nil, kill the Eshell buffer on the `exit' command.
     Otherwise, the buffer will simply be buried.

 -- User Option: eshell-input-filter-functions
     Functions to call before input is processed.  The input is
     contained in the region from `eshell-last-input-start' to
     `eshell-last-input-end'.

 -- User Option: eshell-expand-input-functions
     Functions to call before input is parsed.  Each function is passed
     two arguments, which bounds the region of the current input text.

 -- User Option: eshell-scroll-to-bottom-on-input
     Controls whether input to interpreter causes window to scroll.  If
     nil, then do not scroll.  If t or `all', scroll all windows showing
     buffer.  If `this', scroll only the selected window.

     See `eshell-preinput-scroll-to-bottom'.

 -- User Option: eshell-scroll-to-bottom-on-output
     Controls whether interpreter output causes window to scroll.  If
     nil, then do not scroll.  If t or `all', scroll all windows showing
     buffer.  If `this', scroll only the selected window.  If `others',
     scroll only those that are not the selected window.

     See variable `eshell-scroll-show-maximum-output' and function
     `eshell-postoutput-scroll-to-bottom'.

 -- User Option: eshell-scroll-show-maximum-output
     Controls how interpreter output causes window to scroll.  If
     non-nil, then show the maximum output when the window is scrolled.

     See variable `eshell-scroll-to-bottom-on-output' and function
     `eshell-postoutput-scroll-to-bottom'.

 -- User Option: eshell-buffer-maximum-lines
     The maximum size in lines for eshell buffers.  Eshell buffers are
     truncated from the top to be no greater than this number, if the
     function `eshell-truncate-buffer' is on
     `eshell-output-filter-functions'.

 -- User Option: eshell-output-filter-functions
     Functions to call before output is displayed.  These functions are
     only called for output that is displayed interactively, and not
     for output which is redirected.

 -- User Option: eshell-preoutput-filter-functions
     Functions to call before output is inserted into the buffer.
     These functions get one argument, a string containing the text to
     be inserted.  They return the string as it should be inserted.

 -- User Option: eshell-password-prompt-regexp
     Regexp matching prompts for passwords in the inferior process.
     This is used by `eshell-watch-for-password-prompt'.

 -- User Option: eshell-skip-prompt-function
     A function called from beginning of line to skip the prompt.

 -- User Option: eshell-status-in-modeline
     If non-nil, let the user know a command is running in the modeline.

 -- Command: eshell-mode
     Emacs shell interactive mode.

     jww (1999-10-04): Useful information should go here!



File: eshell.info,  Node: Extension modules,  Next: Command options processing,  Prev: User interface,  Up: Top

7 Extension modules
*******************

The `eshell-module' group is for Eshell extension modules, which
provide optional behavior which the user can enable or disable by
customizing the variable `eshell-modules-list'.

 -- User Option: eshell-module-unload-hook
     A hook run when `eshell-module' is unloaded.

 -- User Option: eshell-modules-list
     A list of optional add-on modules to be loaded by Eshell.  Changes
     will only take effect in future Eshell buffers.


File: eshell.info,  Node: Command options processing,  Next: Process management,  Prev: Extension modules,  Up: Top

8 Command options processing
****************************

The options processing code handles command argument parsing for Eshell
commands implemented in Lisp.

   User Functions:


File: eshell.info,  Node: Process management,  Next: Eshell test suite,  Prev: Command options processing,  Up: Top

9 Process management
********************

When Eshell invokes external commands, it always does so asynchronous,
so that Emacs isn't tied up waiting for the process to finish.

   User Variables:

 -- User Option: eshell-process-wait-seconds
     The number of seconds to delay waiting for a synchronous process.

 -- User Option: eshell-process-wait-milliseconds
     The number of milliseconds to delay waiting for a synchronous
     process.

 -- User Option: eshell-done-messages-in-minibuffer
     If non-nil, subjob "Done" messages will display in minibuffer.

 -- User Option: eshell-delete-exited-processes
     If nil, process entries will stick around until `jobs' is run.
     This variable sets the buffer-local value of
     `delete-exited-processes' in Eshell buffers.

     This variable causes Eshell to mimic the behavior of bash when set
     to nil.  It allows the user to view the exit status of a completed
     subjob (process) at their leisure, because the process entry
     remains in memory until the user examines it using
     \[list-processes].

     Otherwise, if `eshell-done-messages-in-minibuffer' is nil, and this
     variable is set to t, the only indication the user will have that a
     subjob is done is that it will no longer appears in the process
     list display.

     Note that Eshell will have to be restarted for a change in this
     variable's value to take effect.

 -- User Option: eshell-reset-signals
     If a termination signal matches this regexp, the terminal will be
     reset.

 -- User Option: eshell-exec-hook
     Called each time a process is exec'd by
     `eshell-gather-process-output'.  It is passed one argument, which
     is the process that was just started.  It is useful for things
     that must be done each time a process is executed in a eshell mode
     buffer (e.g., `process-kill-without-query').  In contrast,
     `eshell-mode-hook' is only executed once when the buffer is
     created.

 -- User Option: eshell-kill-hook
     Called when a process run by `eshell-gather-process-output' has
     ended.  It is passed two arguments: the process that was just
     ended, and the termination status (as a string).  Note that the
     first argument may be nil, in which case the user attempted to
     send a signal, but there was no relevant process.  This can be
     used for displaying help information, for example.

 -- User Option: eshell-kill-process-wait-time
     Seconds to wait between sending termination signals to a
     subprocess.

 -- User Option: eshell-kill-process-signals
     Signals used to kill processes when an Eshell buffer exits.
     Eshell calls each of these signals in order when an Eshell buffer
     is killed; if the process is still alive afterwards, Eshell waits a
     number of seconds defined by `eshell-kill-process-wait-time', and
     tries the next signal in the list.

 -- User Option: eshell-kill-processes-on-exit
     If non-nil, kill active processes when exiting an Eshell buffer.
     Emacs will only kill processes owned by that Eshell buffer.

     If nil, ownership of background and foreground processes reverts to
     Emacs itself, and will die only if the user exits Emacs, calls
     `kill-process', or terminates the processes externally.

     If `ask', Emacs prompts the user before killing any processes.

     If `every', it prompts once for every process.

     If t, it kills all buffer-owned processes without asking.

     Processes are first sent SIGHUP, then SIGINT, then SIGQUIT, then
     SIGKILL.  The variable `eshell-kill-process-wait-time' specifies
     how long to delay between signals.


File: eshell.info,  Node: Eshell test suite,  Next: General utilities,  Prev: Process management,  Up: Top

10 Eshell test suite
********************

This module is meant to ensure that Eshell is working correctly.

   The purpose of this module is to verify that Eshell works as
expected.  To run it on your system, use the command `M-x eshell-test'.


File: eshell.info,  Node: General utilities,  Next: Variable handling,  Prev: Eshell test suite,  Up: Top

11 General utilities
********************

This is general utility code, meant for use by Eshell itself.

 -- User Option: eshell-group-file
     If non-nil, the name of the group file on your system.

 -- User Option: eshell-passwd-file
     If non-nil, the name of the passwd file on your system.

 -- User Option: eshell-handle-errors
     If non-nil, Eshell will handle errors itself.  Setting this to nil
     is offered as an aid to debugging only.

 -- User Option: eshell-private-file-modes
     The file-modes value to use for creating "private" files.

 -- User Option: eshell-private-directory-modes
     The file-modes value to use for creating "private" directories.


File: eshell.info,  Node: Variable handling,  Next: Command aliases,  Prev: General utilities,  Up: Top

12 Variable handling
********************

Variable interpolation is introduced whenever the `$' character appears
unquoted in any argument (except when that argument is surrounded by
single quotes) .  It may be used to interpolate a variable value, a
subcommand, or even the result of a Lisp form.

   These are the possible variable interpolation syntaxes.  Also keep
in mind that if an argument looks like a number, it will be converted
to a number.  This is not significant when invoking external commands,
but it's important when calling Lisp functions.

     $VARIABLE

   Interval the value of an environment variable, or a Lisp variable

     $ALSO-VAR

   "-" is a legal part of a variable name.

     $<MYVAR>-TOO

   Only "MYVAR" is part of the variable name in this case.

     $#VARIABLE

   Returns the length of the value of VARIABLE.  This could also be
done using the `length' Lisp function.

     $(lisp)

   Returns result of lisp evaluation.  Note: Used alone like this, it
is identical to just saying (lisp); but with the variable expansion
form, the result may be interpolated a larger string, such as
`$(lisp)/other'.

     ${command}

   Returns the value of an eshell subcommand.  See the note above
regarding Lisp evaluations.

     $ANYVAR[10]

   Return the 10th element of ANYVAR.  If ANYVAR's value is a string,
it will be split in order to make it a list.  The splitting will occur
at whitespace.

     $ANYVAR[: 10]

   As above, except that splitting occurs at the colon now.

     $ANYVAR[: 10 20]

   As above, but instead of returning just a string, it now returns a
list of two strings.  If the result is being interpolated into a larger
string, this list will be flattened into one big string, with each
element separated by a space.

     $ANYVAR["\\\\" 10]

   Separate on backslash characters.  Actually, the first argument-- if
it doesn't have the form of a number, or a plain variable name --can be
any regular expression.  So to split on numbers, use `$ANYVAR["[0-9]+"
10 20]'.

     $ANYVAR[hello]

   Calls `assoc' on ANYVAR with `hello', expecting it to be an alist.

     $#ANYVAR[hello]

   Returns the length of the cdr of the element of ANYVAR who car is
equal to "hello".

   There are also a few special variables defined by Eshell.  `$$' is
the value of the last command (t or nil, in the case of an external
command).  This makes it possible to chain results:

     /tmp $ echo /var/spool/mail/johnw
     /var/spool/mail/johnw
     /tmp $ dirname $$
     /var/spool/mail/
     /tmp $ cd $$
     /var/spool/mail $

   `$_' refers to the last argument of the last command.  And $?
contains the exit code of the last command (0 or 1 for Lisp functions,
based on successful completion).

 -- User Option: eshell-prefer-lisp-variables
     If non-nil, prefer Lisp variables to environment variables.

 -- User Option: eshell-complete-export-definition
     If non-nil, completing names for `export' shows current definition.

 -- User Option: eshell-variable-name-regexp
     A regexp identifying what constitutes a variable name reference.
     Note that this only applies for `$NAME'.  If the syntax `$<NAME>'
     is used, then NAME can contain any character, including angle
     brackets, if they are quoted with a backslash.

 -- User Option: eshell-variable-aliases-list
     This list provides aliasing for variable references.  It is very
     similar in concept to what `eshell-user-aliases-list' does for
     commands.  Each member of this defines defines the name of a
     command, and the Lisp value to return for that variable if it is
     accessed via the syntax `$NAME'.

     If the value is a function, that function will be called with two
     arguments: the list of the indices that was used in the reference,
     and whether the user is requesting the length of the ultimate
     element.  For example, a reference of `$NAME[10][20]' would result
     in the function for alias `NAME' being called (assuming it were
     aliased to a function), and the arguments passed to this function
     would be the list `(10 20)', and nil.


File: eshell.info,  Node: Command aliases,  Next: Login banner,  Prev: Variable handling,  Up: Top

13 Command aliases
******************

Command aliases allow for easy definition of alternate commands.

   Command aliases greatly simplify the definition of new commands.
They exist as an alternative to alias functions, which are otherwise
quite superior, being more flexible and natural to the Emacs Lisp
environment (if somewhat trickier to define; *note Alias functions::).

* Menu:

* Creating aliases::
* Auto-correction of bad commands::


File: eshell.info,  Node: Creating aliases,  Next: Auto-correction of bad commands,  Prev: Command aliases,  Up: Command aliases

13.1 Creating aliases
=====================

The user interface is simple: type `alias' followed by the command name
followed by the definition.  Argument references are made using `$1',
`$2', etc., or `$*'.  For example:

     alias ll 'ls -l $*'

   This will cause the command `ll NEWS' to be replaced by `ls -l
NEWS'.  This is then passed back to the command parser for reparsing.(1)

   To delete an alias, specify its name without a definition:

     alias ll

   Aliases are written to disk immediately after being defined or
deleted.  The filename in which they are kept is defined by the
following variable:

 -- User Option: eshell-aliases-file
     The file in which aliases are kept.  Whenever an alias is defined
     by the user, using the `alias' command, it will be written to this
     file.  Thus, alias definitions (and deletions) are always
     permanent.  This approach was chosen for the sake of simplicity,
     since that's pretty much the only benefit to be gained by using
     this module.

   The format of this file is quite basic.  It specifies the alias
definitions in almost exactly the same way that the user entered them,
minus any argument quoting (since interpolation is not done when the
file is read).  Hence, it is possible to add new aliases to the alias
file directly, using a text editor rather than the `alias' command.
Or, this method can be used for editing aliases that have already
defined.

   Here is an example of a few different aliases, and they would appear
in the aliases file:

     alias clean rm -fr **/.#*~
     alias commit cvs commit -m changes $*
     alias ll ls -l $*
     alias info (info)
     alias reindex glimpseindex -o ~/Mail
     alias compact for i in ~/Mail/**/*~*.bz2(Lk+50) { bzip2 -9v $i }

   ---------- Footnotes ----------

   (1) Only the command text specified in the alias definition will be
reparsed.  Argument references (such as `$*') are handled using
variable values, which means that the expansion will not be reparsed,
but used directly.


File: eshell.info,  Node: Auto-correction of bad commands,  Prev: Creating aliases,  Up: Command aliases

13.2 Auto-correction of bad commands
====================================

When a user enters the same unknown command many times during a
session, it is likely that they are experiencing a spelling difficulty
associated with a certain command.  To combat this, Eshell will offer
to automatically define an alias for that mispelled command, once a
given tolerance threshold has been reached.

 -- User Option: eshell-bad-command-tolerance
     The number of failed commands to ignore before creating an alias.

   Whenever the same bad command name is encountered this many times,
the user will be prompted in the minibuffer to provide an alias name.
An alias definition will then be created which will result in an equal
call to the correct name.  In this way, Eshell gradually learns about
the commands that the user mistypes frequently, and will automatically
correct them!

   Note that a `$*' is automatically appended at the end of the alias
definition, so that entering it is unnecessary when specifying the
corrected command name.


File: eshell.info,  Node: Login banner,  Next: Basic shell commands,  Prev: Command aliases,  Up: Top

14 Login banner
***************

This sample module displays a welcome banner at login.  It exists so
that others wishing to create their own Eshell extension modules may
have a simple template to begin with.

   There is nothing to be done or configured in order to use this
module, other than to select it by customizing the variable
`eshell-modules-list'.  It will then display a version information
message whenever Eshell is loaded.

   This code is only an example of a how to write a well-formed
extension module for Eshell.  The better way to display login text is
to use the `eshell-script' module, and to echo the desired strings from
the user's `eshell-login-script' file.

   There is one configuration variable, which demonstrates how to
properly define a customization variable in an extension module.  In
this case, it allows the user to change the string which displays at
login time.

 -- User Option: eshell-banner-message
     The banner message to be displayed when Eshell is loaded.  This
     can be any sexp, and should end with at least two newlines.


File: eshell.info,  Node: Basic shell commands,  Next: Argument completion,  Prev: Login banner,  Up: Top

15 Basic shell commands
***********************

The "basic" code provides a set of convenience functions which are
traditionally considered shell builtins.  Since all of the
functionality provided by them is accessible through Lisp, they are not
really builtins at all, but offer a command-oriented way to do the same
thing.

   There are very few basic Eshell commands--so-called builtins.  They
are: echo, umask, and version.

* Menu:

* `echo'::
* `umask'::
* `version'::


File: eshell.info,  Node: `echo',  Next: `umask',  Prev: Basic shell commands,  Up: Basic shell commands

15.1 `echo'
===========

The `echo' command repeats its arguments to the screen.  It is optional
whether this is done in a Lisp-friendly fashion (so that the value of
echo is useful to a Lisp command using the result of echo as an
argument), or whether it should try to act like a normal shell echo,
and always result in a flat string being returned.

 -- User Option: eshell-plain-echo-behavior
     If non-nil, `echo' tries to behave like an ordinary shell echo.
     This comes at some detriment to Lisp functionality.  However, the
     Lisp equivalent of `echo' can always be achieved by using
     `identity'.

   An example of the difference is the following:

     echo Hello world

   If `eshell-plain-echo-behavior' is non-nil, this will yield the
string "Hello world".  If Lisp behavior is enabled, however, it will
yield a list whose two elements are the strings "Hello" and "world".
The way to write an equivalent expression for both would be:

     echo "Hello world"

   This always returns a single string.


File: eshell.info,  Node: `umask',  Next: `version',  Prev: `echo',  Up: Basic shell commands

15.2 `umask'
============

The umask command changes the default file permissions for newly
created files.  It uses the same syntax as bash.


File: eshell.info,  Node: `version',  Prev: `umask',  Up: Basic shell commands

15.3 `version'
==============

This command reports the version number for Eshell and all its
dependent module, including the date when those modules were last
modified.


File: eshell.info,  Node: Argument completion,  Next: Directory navigation,  Prev: Basic shell commands,  Up: Top

16 Argument completion
**********************

This module provides a programmable completion function bound to the
TAB key, which allows for completing command names, file names,
variable names, arguments, etc.

   Eshell, by using the pcomplete package, provides a full programmable
completion facility that is comparable to shells like tcsh or zsh.

   Completions are context-sensitive, which means that pressing `TAB'
after the command `rmdir' will result in a list of directories, while
doing so after `rm' will result in a list of all file entries.

   Many builtin completion rules are provided, for commands such as
`cvs', or RedHat's `rpm' utility.  Adding new completion rules is no
more difficult than writing a plain Lisp functions, and they can be
debugged, profiled, and compiled using exactly the same facilities
(since in fact, they *are* just Lisp functions).  See the definition of
the function `pcomplete/make' for an example of how to write a
completion function.

   The completion facility is very easy to use.  Just press TAB.  If
there are a large number of possible completions, a buffer will
appearing showing a list of them.  Completions may be selected from
that buffer using the mouse.  If no completion is selected, and the
user starts doing something else, the display buffer will automatically
disappear.

   If the list of possible completions is very small, Eshell will
"cycle" through them, selecting a different entry each time `TAB' is
pressed.  `S-TAB' may be used to cycle in the opposite direction.

   Glob patterns can also be cycled.  For example, entering `echo
x*<tab>' will cycle through all the filenames beginning with `x'.  This
is done because the glob list is treated as though it were a list of
possible completions.  Pressing `C-c SPC' will insert all of the
matching glob patterns at point.

   If a Lisp form is being entered, `TAB' will complete the Lisp symbol
name, in exactly the same way that `M-TAB' does in Emacs Lisp mode.

   The list of possible completions can be viewed at any point by
pressing `M-?'.

   Finally, context-related help can be accessed by pressing `C-c i'.
This only works well if the completion function has provided Eshell
with sufficient pointers to locate the relevant help text.

 -- User Option: eshell-show-lisp-completions
     If non-nil, include Lisp functions in the command completion list.
     If this variable is nil, Lisp completion can still be done in
     command position by using M-TAB instead of TAB.

 -- User Option: eshell-no-completion-during-jobs
     If non-nil, don't allow completion while a process is running.

 -- User Option: eshell-command-completions-alist
     An alist that defines simple argument type correlations.  This is
     provided for common commands, as a simplistic alternative to
     writing a completion function.

 -- User Option: eshell-cmpl-file-ignore
     A regexp of filenames to be disregarded during file completion.

 -- User Option: eshell-cmpl-dir-ignore
     A regexp of names to be disregarded during directory completion.

 -- User Option: eshell-cmpl-ignore-case
     If non-nil, ignore case when doing filename completion.

 -- User Option: eshell-cmpl-autolist
     If non-nil, automatically list possibilities on partial completion.
     This mirrors the optional behavior of tcsh.

 -- User Option: eshell-cmpl-suffix-list
     A list of characters which constitute a proper suffix.

 -- User Option: eshell-cmpl-recexact
     If non-nil, use shortest completion if characters cannot be added.
     This mirrors the optional behavior of tcsh.

     A non-nil value is useful if `pcomplete-autolist' is non-nil too.

 -- User Option: eshell-cmpl-man-function
     A function to that will be called to display a manual page.  It
     will be passed the name of the command to document.

 -- User Option: eshell-cmpl-compare-entry-function
     This function is used to order file entries for completion.  The
     behavior of most all shells is to sort alphabetically.

 -- User Option: eshell-cmpl-expand-before-complete
     If non-nil, expand the current argument before completing it.
     This means that typing something such as `$HOME/bi' followed by
     M-x pcomplete-argument will cause the variable reference to be
     resolved first, and the resultant value that will be completed
     against to be inserted in the buffer.  Note that exactly what gets
     expanded and how is entirely up to the behavior of the
     `pcomplete-parse-arguments-function'.

 -- User Option: eshell-cmpl-cycle-completions
     If non-nil, hitting the TAB key cycles through the completion list.
     Typical Emacs behavior is to complete as much as possible, then
     pause waiting for further input.  Then if TAB is hit again, show a
     list of possible completions.  When `pcomplete-cycle-completions'
     is non-nil, it acts more like zsh or 4nt, showing the first
     maximal match first, followed by any further matches on each
     subsequent pressing of the TAB key.  M-x pcomplete-list is the key
     to press if the user wants to see the list of possible completions.

 -- User Option: eshell-cmpl-cycle-cutoff-length
     If the number of completions is greater than this, don't cycle.
     This variable is a compromise between the traditional Emacs style
     of completion, and the "cycling" style.  Basically, if there are
     more than this number of completions possible, don't automatically
     pick the first one and then expect the user to press TAB to cycle
     through them.  Typically, when there are a large number of
     completion possibilities, the user wants to see them in a list
     buffer so that they can know what options are available.  But if
     the list is small, it means the user has already entered enough
     input to disambiguate most of the possibilities, and therefore
     they are probably most interested in cycling through the
     candidates.  Set this value to nil if you want cycling to always
     be enabled.

 -- User Option: eshell-cmpl-restore-window-delay
     The number of seconds to wait before restoring completion windows.
     Once the completion window has been displayed, if the user then
     goes on to type something else, that completion window will be
     removed from the display (actually, the original window
     configuration before it was displayed will be restored), after
     this many seconds of idle time.  If set to nil, completion windows
     will be left on second until the user removes them manually.  If
     set to 0, they will disappear immediately after the user enters a
     key other than TAB.

 -- User Option: eshell-command-completion-function
     Function called for completing the initial command argument.

 -- User Option: eshell-cmpl-command-name-function
     Function called for determining the current command name.

 -- User Option: eshell-default-completion-function
     Function called when no completion rule can be found.  This
     function is used to generate completions for every argument.


File: eshell.info,  Node: Directory navigation,  Next: Extended filename globbing,  Prev: Argument completion,  Up: Top

17 Directory navigation
***********************

Directory navigation involves changing directories, examining the
current directory, maintaining a directory stack, and also keeping
track of a history of the last directory locations the user was in.
Emacs does provide standard Lisp definitions of `pwd' and `cd', but
they lack somewhat in feel from the typical shell equivalents.

   The only special feature that Eshell offers in the last-dir-ring.
To view the ring, enter:

     cd =

   Changing to an index within the ring is done using:

     cd -      ; same as cd -0
     cd -4

   Or, it is possible to change the first member in the ring which
matches a regexp:

     cd =bcc   ; change to the last directory visited containing "bcc"

   This ring is maintained automatically, and is persisted across
Eshell sessions.  It is a separate mechanism from `pushd' and `popd',
and the two may be used at the same time.

 -- User Option: eshell-pwd-convert-function
     The function used to normalize the value of Eshell's `pwd'.  The
     value returned by `pwd' is also used when recording the
     last-visited directory in the last-dir-ring, so it will affect the
     form of the list used by `cd ='.

 -- User Option: eshell-ask-to-save-last-dir
     Determine if the last-dir-ring should be automatically saved.  The
     last-dir-ring is always preserved when exiting an Eshell buffer.
     However, when Emacs is being shut down, this variable determines
     whether to prompt the user, or just save the ring.  If set to nil,
     it means never ask whether to save the last-dir-ring.  If set to
     t, always ask if any Eshell buffers are open at exit time.  If set
     to `always', the list-dir-ring will always be saved, silently.

 -- User Option: eshell-cd-shows-directory
     If non-nil, using `cd' will report the directory it changes to.

 -- User Option: eshell-cd-on-directory
     If non-nil, do a cd if a directory is in command position.

 -- User Option: eshell-directory-change-hook
     A hook to run when the current directory changes.

 -- User Option: eshell-list-files-after-cd
     If non-nil, call "ls" with any remaining args after doing a cd.
     This is provided for convenience, since the same effect is easily
     achieved by adding a function to `eshell-directory-change-hook'
     that calls "ls" and references `eshell-last-arguments'.

 -- User Option: eshell-pushd-tohome
     If non-nil, make pushd with no arg behave as `pushd ~' (like `cd').
     This mirrors the optional behavior of tcsh.

 -- User Option: eshell-pushd-dextract
     If non-nil, make "pushd +n" pop the nth dir to the stack top.
     This mirrors the optional behavior of tcsh.

 -- User Option: eshell-pushd-dunique
     If non-nil, make pushd only add unique directories to the stack.
     This mirrors the optional behavior of tcsh.

 -- User Option: eshell-dirtrack-verbose
     If non-nil, show the directory stack following directory change.
     This is effective only if directory tracking is enabled.

 -- User Option: eshell-last-dir-ring-file-name
     If non-nil, name of the file to read/write the last-dir-ring.  See
     also `eshell-read-last-dir-ring' and `eshell-write-last-dir-ring'.
     If it is nil, the last-dir-ring will not be written to disk.

 -- User Option: eshell-last-dir-ring-size
     If non-nil, the size of the directory history ring.  This ring is
     added to every time `cd' or `pushd' is used.  It simply stores the
     most recent directory locations Eshell has been in.  To return to
     the most recent entry, use `cd -' (equivalent to `cd -0').  To
     return to an older entry, use `cd -N', where N is an integer less
     than `eshell-last-dir-ring-size'.  To return to the last directory
     matching a particular regexp, use `cd =REGEXP'.  To display the
     directory history list, use `cd ='.

     This mechanism is very similar to that provided by `pushd', except
     it's far more automatic.  `pushd' allows the user to decide which
     directories gets pushed, and its size is unlimited.

     `eshell-last-dir-ring' is meant for users who don't use `pushd'
     explicity very much, but every once in a while would like to
     return to a previously visited directory without having to type in
     the whole thing again.

 -- User Option: eshell-last-dir-unique
     If non-nil, `eshell-last-dir-ring' contains only unique entries.


File: eshell.info,  Node: Extended filename globbing,  Next: History list management,  Prev: Directory navigation,  Up: Top

18 Extended filename globbing
*****************************

This module provides extended globbing syntax, similar what is used by
zsh for filename generation.

   The globbing code used by Eshell closely follows the syntax used by
zsh.  Basically, here is a summary of examples:

     echo a*       ; anything starting with 'a'
     echo a#b      ; zero or more 'a's, then 'b'
     echo a##b     ; one or more 'a's, then 'b'
     echo a?       ; a followed by any character
     echo a*~ab    ; 'a', then anything, but not 'ab'
     echo c*~*~    ; all files beginning with 'c', except backups (*~)

   Recursive globbing is also supported:

     echo **/*.c   ; all '.c' files at or under current directory
     echo ***/*.c  ; same as above, but traverse symbolic links

   Using argument predication, the recursive globbing syntax is
sufficient to replace the use of `find expr | xargs cmd' in most cases.
For example, to change the readership of all files belonging to `johnw'
in the `/tmp' directory or lower, use:

     chmod go-r /tmp/**/*(u'johnw')

   The glob above matches all of the files beneath `/tmp' that are
owned by the user `johnw'.  See *note Value modifiers and predicates::,
for more information about argument predication.

 -- User Option: eshell-glob-include-dot-files
     If non-nil, glob patterns will match files beginning with a dot.

 -- User Option: eshell-glob-include-dot-dot
     If non-nil, glob patterns that match dots will match . and ..

 -- User Option: eshell-glob-case-insensitive
     If non-nil, glob pattern matching will ignore case.

 -- User Option: eshell-glob-show-progress
     If non-nil, display progress messages during a recursive glob.

 -- User Option: eshell-error-if-no-glob
     If non-nil, it is an error for a glob pattern not to match.   This
     mimcs the behavior of zsh if non-nil, but bash if nil.

 -- User Option: eshell-glob-chars-list
     List of additional characters used in extended globbing.

 -- User Option: eshell-glob-translate-alist
     An alist for translation of extended globbing characters.


File: eshell.info,  Node: History list management,  Next: Implementation of `ls' in Lisp,  Prev: Extended filename globbing,  Up: Top

19 History list management
**************************

This module provides command history management.

   Eshell's history facility imitates the syntax used by bash
([(bash)History Interaction]).  Thus:

     !ls           ; repeat the last command beginning with 'ls'
     !?ls          ; repeat the last command containing ls
     echo !ls:2    ; echo the second arg of the last 'ls' command
     !ls<tab>      ; complete against all possible words in this
                   ; position, by looking at the history list
     !ls<C-c SPC>  ; expand any matching history input at point

   Also, most of `comint-mode's keybindings are accepted:

     M-r     ; search backward for a previous command by regexp
     M-s     ; search forward for a previous command by regexp
     M-p     ; access the last command entered, repeatable
     M-n     ; access the first command entered, repeatable

     C-c M-r ; using current input, find a matching command thus, with
             ; 'ls' as the current input, it will go back to the same
             ; command that '!ls' would have selected
     C-c M-s ; same, but in reverse order

   Note that some of these keybindings are only available if the
`eshell-rebind' is not in use, in which case M-p does what C-c M-r
normally would do, and C-p is used instead of M-p.  It may seem
confusing, but the intention is to make the most useful functionality
the most easily accessible.  If `eshell-rebind' is not being used,
history navigation will use comint's keybindings; if it is, history
navigation tries to use similar keybindings to bash.  This is all
configurable, of course.


File: eshell.info,  Node: Implementation of `ls' in Lisp,  Next: Value modifiers and predicates,  Prev: History list management,  Up: Top

20 Implementation of `ls' in Lisp
*********************************

This module implements the "ls" utility fully in Lisp.  If it is passed
any unrecognized command switches, it will revert to the operating
system's version.  This version of "ls" uses text properties to
colorize its output based on the setting of `eshell-ls-use-colors'.

   Most of the command switches recognized by GNU's ls utility are
supported ([(fileutils)ls invocation]).

 -- User Option: eshell-ls-unload-hook
     When unloading `eshell-ls', restore the definition of
     `insert-directory'.

 -- User Option: eshell-ls-use-in-dired
     If non-nil, use `eshell-ls' to read directories in dired.

 -- User Option: eshell-ls-default-blocksize
     The default blocksize to use when display file sizes with -s.

 -- User Option: eshell-ls-initial-args
     If non-nil, any interactive usage of ls implies these args first.
     This can be used to make the `-h' flag (display in human readable
     format) the default, for example.  This variable is ignored if
     output is being redirected.

 -- User Option: eshell-ls-exclude-regexp
     Unless -a is specified, files matching this regexp will not be
     shown.

 -- User Option: eshell-ls-use-colors
     If non-nil, use colors in file listings.

 -- User Option: eshell-ls-archive-regexp
     A regular expression that matches names of file archives.  This
     typically includes both traditional archives and compressed files.

 -- User Option: eshell-ls-backup-regexp
     A regular expression that matches names of backup files.

 -- User Option: eshell-ls-product-regexp
     A regular expression that matches names of product files.
     Products are files that get generated from a source file, and hence
     ought to be recreatable if they are deleted.

 -- User Option: eshell-ls-clutter-regexp
     A regular expression that matches names of junk files.  These are
     mainly files that get created for various reasons, but don't
     really need to stick around for very long.

 -- User Option: eshell-ls-highlight-alist
     This alist correlates test functions to color.  The format of the
     members of this alist is

          (TEST-SEXP . FACE)

     If TEST-SEXP evals to non-nil, that face will be used to highlight
     the name of the file.  The first match wins.  `file' and `attrs'
     are in scope during the evaluation of TEST-SEXP.


File: eshell.info,  Node: Value modifiers and predicates,  Next: Command prompts,  Prev: Implementation of `ls' in Lisp,  Up: Top

21 Value modifiers and predicates
*********************************

This module allows for predicates to be applied to globbing patterns
(similar to zsh), in addition to string modifiers which can be applied
either to globbing results, variable references, or just ordinary
strings.

   Argument predication is used to affect which members of a list are
selected for use as argument.  This is most useful with globbing, but
can be used on any list argument, to select certain members.

   Argument modifiers are used to manipulate argument values.  For
example, sorting lists, upcasing words, substituting characters, etc.

   Here are some examples of how to use argument predication.  Most of
the predicates and modifiers are modeled after those provided by zsh.

     ls -ld *(/)           ; list all directories
     ls -l *(@u'johnw')    ; list all symlinks owned by 'johnw'
     bzip2 -9v **/*(a+30)  ; compress everything which hasn't been
                             accessed in 30 days
     echo *.c(:o:R)     ; a reversed, sorted list of C files
     * (^@:U^u0)         ; all non-symlinks not owned by 'root', upcased
     chmod u-x *(U*)    : remove exec bit on all executables owned by user

   See the zsh docs for more on the syntax ([(zsh.info)Filename
Generation]).

 -- User Option: eshell-predicate-alist
     A list of predicates than can be applied to a globbing pattern.
     The format of each entry is

          (CHAR . PREDICATE-FUNC-SEXP)

 -- User Option: eshell-modifier-alist
     A list of modifiers than can be applied to an argument expansion.
     The format of each entry is

          (CHAR ENTRYWISE-P MODIFIER-FUNC-SEXP)


File: eshell.info,  Node: Command prompts,  Next: Rebind keys at input,  Prev: Value modifiers and predicates,  Up: Top

22 Command prompts
******************

This module provides command prompts, and navigation between them, as
is common with most shells.

   Most of the prompt navigation commands of `comint-mode' are
supported, such as C-c C-n, C-c C-p, etc.

 -- User Option: eshell-prompt-function
     A function that returns the Eshell prompt string.  Make sure to
     update `eshell-prompt-regexp' so that it will match your prompt.

 -- User Option: eshell-prompt-regexp
     A regexp which fully matches your eshell prompt.  This setting is
     important, since it affects how eshell will interpret the lines
     that are passed to it.  If this variable is changed, all Eshell
     buffers must be exited and re-entered for it to take effect.

 -- User Option: eshell-highlight-prompt
     If non-nil, Eshell should highlight the prompt.

 -- User Option: eshell-before-prompt-hook
     A list of functions to call before outputting the prompt.

 -- User Option: eshell-after-prompt-hook
     A list of functions to call after outputting the prompt.  Note
     that if `eshell-scroll-show-maximum-output' is non-nil, then
     setting `eshell-show-maximum-output' here won't do much.  It
     depends on whether the user wants the resizing to happen while
     output is arriving, or after.


File: eshell.info,  Node: Rebind keys at input,  Next: Running script files.,  Prev: Command prompts,  Up: Top

23 Rebind keys at input
***********************

This module allows for special keybindings that only take effect while
the point is in a region of input text.  By default, it binds C-a to
move to the beginning of the input text (rather than just the beginning
of the line), and C-p and C-n to move through the input history, C-u
kills the current input text, etc.  It also, if
`eshell-confine-point-to-input' is non-nil, does not allow certain
commands to cause the point to leave the input area, such as
`backward-word', `previous-line', etc.  This module intends to mimic
the behavior of normal shells while the user editing new input text.

   User Variables:

 -- User Option: eshell-rebind-keys-alist
     Bind some keys differently if point is in input text.

 -- User Option: eshell-confine-point-to-input
     If non-nil, do not allow the point to leave the current input.
     This is more difficult to do nicely in Emacs than one might think.
     Basically, the `point-left' attribute is added to the input text,
     and a function is placed on that hook to take the point back to
     `eshell-last-output-end' every time the user tries to move away.
     But since there are many cases in which the point _ought_ to move
     away (for programmatic reasons), the variable
     `eshell-cannot-leave-input-list' defines commands which are
     affected from this rule.  However, this list is by no means as
     complete as it probably should be, so basically all one can hope
     for is that other people will left the point alone in the Eshell
     buffer.  Sigh.

 -- User Option: eshell-error-if-move-away
     If non-nil, consider it an error to try to move outside current
     input.  This is default behavior of shells like bash.

 -- User Option: eshell-remap-previous-input
     If non-nil, remap input keybindings on previous prompts as well.

 -- User Option: eshell-cannot-leave-input-list
     A list of commands that cannot leave the input area.


File: eshell.info,  Node: Running script files.,  Next: Smart display of output,  Prev: Rebind keys at input,  Up: Top

24 Running script files.
************************

This module allows for the execution of files containing Eshell
commands, as a script file.

   User Variables:

 -- User Option: eshell-login-script
     If non-nil, a file to invoke when starting up Eshell interactively.
     This file should be a file containing Eshell commands, where
     comment lines begin with `#'.

 -- User Option: eshell-rc-script
     If non-nil, a file to invoke whenever Eshell is started.  This
     includes when running `eshell-command'.


File: eshell.info,  Node: Smart display of output,  Next: Running visual commands,  Prev: Running script files.,  Up: Top

25 Smart display of output
**************************

This module combines the facility of normal, modern shells with some of
the edit/review concepts inherent in the design of Plan 9's 9term.  See
the docs for more details.

   Most likely you will have to turn this option on and play around with
it to get a real sense of how it works.

   The best way to get a sense of what this code is trying to do is by
using it.  Basically, the philosophy represents a blend between the
ease of use of modern day shells, and the review-before-you-proceed
mentality of Plan 9's 9term.

   * When you invoke a command, it is assumed that you want to read the
     output of that command.

   * If the output is not what you wanted, it is assumed that you will
     want to edit, and then resubmit a refined version of that command.

   * If the output is valid, pressing any self-inserting character key
     will jump to end of the buffer and insert that character, in order
     to begin entry of a new command.

   * If you show an intention to edit the previous command--by moving
     around within it--then the next self-inserting characters will
     insert *there*, instead of at the bottom of the buffer.

   * If you show an intention to review old commands, such as M-p or
     M-r, point will jump to the bottom of the buffer before invoking
     that command.

   * If none of the above has happened yet (i.e., your point is just
     sitting on the previous command), you can use SPACE and BACKSPACE
     (or DELETE) to page forward and backward *through the output of
     the last command only*.  It will constrain the movement of the
     point and window so that the maximum amount of output is always
     displayed at all times.

   * While output is being generated from a command, the window will be
     constantly reconfigured (until it would otherwise make no
     difference) in order to always show you the most output from the
     command possible.  This happens if you change window sizes,
     scroll, etc.

   * Like I said, it's not really comprehensible until you try it! ;)

 -- User Option: eshell-smart-unload-hook
     A hook that gets run when `eshell-smart' is unloaded.

 -- User Option: eshell-review-quick-commands
     If nil, point does not stay on quick commands.  A quick command is
     one that produces no output, and exits successfully.

 -- User Option: eshell-smart-display-navigate-list
     A list of commands which cause Eshell to jump to the end of buffer.

 -- User Option: eshell-smart-space-goes-to-end
     If non-nil, space will go to end of buffer when point-max is
     visible.  That is, if a command is running and the user presses
     SPACE at a time when the end of the buffer is visible, point will
     go to the end of the buffer and smart-display will be turned off
     (that is, subsequently pressing backspace will not cause the
     buffer to scroll down).

     This feature is provided to make it very easy to watch the output
     of a long-running command, such as make, where it's more desirable
     to see the output go by than to review it afterward.

     Setting this variable to nil means that space and backspace will
     always have a consistent behavior, which is to move back and forth
     through displayed output.  But it also means that enabling output
     tracking requires the user to manually move point to the end of the
     buffer using \[end-of-buffer].

 -- User Option: eshell-where-to-jump
     This variable indicates where point should jump to after a command.
     The options are `begin', `after' or `end'.


File: eshell.info,  Node: Running visual commands,  Next: UNIX commands in Lisp,  Prev: Smart display of output,  Up: Top

26 Running visual commands
**************************

This module causes visual commands (e.g., `vi') to be executed by the
`term' package, which comes with Emacs.  This package handles most of
the ANSI control codes, allowing curses-based applications to run
within an Emacs window.  The variable `eshell-visual-commands' defines
which commands are considered visual in nature.

   At the moment, eshell is stream-based in its interactive input and
output.  This means that full-screen commands, such as "vi" or "lynx",
will not display correctly.  These are therefore thought of as "visual"
programs.  In order to run these progrem under Emacs, Eshell uses the
term.el package, and invokes them in a separate buffer, giving the
illusion that Eshell itself is allowing these visual processes to
execute.

 -- User Option: eshell-visual-commands
     A list of commands that present their output in a visual fashion.

 -- User Option: eshell-term-name
     Name to use for the TERM variable when running visual commands.
     See `term-term-name' in term.el for more information on how this is
     used.

 -- User Option: eshell-escape-control-x
     If non-nil, allow `C-x' to be handled by Emacs key in visual
     buffers.  See the variable `eshell-visual-commands'.  If this
     variable is set to nil, `C-x' will send that control character to
     the invoked process.


File: eshell.info,  Node: UNIX commands in Lisp,  Next: Extra alias functions,  Prev: Running visual commands,  Up: Top

27 UNIX commands in Lisp
************************

This module defines many of the more common UNIX utilities as aliases
implemented in Lisp.  These include mv, ln, cp, rm, etc.  If the user
passes arguments which are too complex, or are unrecognized by the Lisp
variant, the external version will be called (if available).  The only
reason not to use them would be because they are usually much slower.
But in several cases their tight integration with Eshell makes them
more versatile than their traditional cousins (such as being able to
use `kill' to kill Eshell background processes by name).

   This file contains implementations of several UNIX command in Emacs
Lisp, for several reasons:

     1) it makes them available on all platforms where the Lisp
        functions used are available

     2) it makes their functionality accessible and modified by the
        Lisp programmer.

     3) it allows Eshell to refrain from having to invoke external
        processes for common operations.

 -- User Option: eshell-rm-removes-directories
     If non-nil, `rm' will remove directory entries.  Otherwise,
     `rmdir' is required.


File: eshell.info,  Node: Extra alias functions,  Prev: UNIX commands in Lisp,  Up: Top

28 Extra alias functions
************************

This module defines some extra alias functions which are entirely
optional.  They can be viewed as samples for how to write Eshell alias
functions, or as aliases which make some of Emacs' behavior more
naturally accessible within Emacs.

 -- User Option: eshell-xtra-hostnames
     Cache the names of frequently accessed hosts.

 -- User Option: eshell-xtra-hosts-file
     The name of the /etc/hosts file.



Tag Table:
Node: Top1479
Node: The Emacs shell3355
Node: What does Eshell offer you?3742
Node: Supported versions of Emacs5313
Node: Known problems5659
Node: Downloading the latest version6375
Node: Eshell is free software6775
Node: How to begin7647
Node: Philosophy8025
Node: Influences13138
Node: User Options13448
Node: Running Eshell14042
Node: Reporting bugs15328
Node: Argument parsing16049
Node: Command invocation17141
Node: Invoking external commands17554
Node: Invoking Lisp functions17961
Node: Alias functions18943
Node: Lisp arguments19702
Node: Command hooks20761
Node: External commands23705
Node: I/O management26761
Node: Insertion27501
Node: Pseudo-devices27738
Node: Multiple output targets28139
Node: User interface29652
Node: Extension modules34809
Node: Command options processing35402
Node: Process management35703
Node: Eshell test suite39475
Node: General utilities39831
Node: Variable handling40621
Node: Command aliases44835
Node: Creating aliases45384
Ref: Creating aliases-Footnote-147320
Node: Auto-correction of bad commands47545
Node: Login banner48693
Node: Basic shell commands49874
Node: `echo'50460
Node: `umask'51592
Node: `version'51831
Node: Argument completion52084
Node: Directory navigation59269
Node: Extended filename globbing63812
Node: History list management66021
Node: Implementation of `ls' in Lisp67783
Node: Value modifiers and predicates70323
Node: Command prompts72118
Node: Rebind keys at input73527
Node: Running script files.75616
Node: Smart display of output76262
Node: Running visual commands79998
Node: UNIX commands in Lisp81502
Node: Extra alias functions82767

End Tag Table
